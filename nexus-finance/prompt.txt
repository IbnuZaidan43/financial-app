oke aku pakai src/lib.prisma.ts ini berarti
import { PrismaClient } from '@prisma/client';
import { PrismaPg } from '@prisma/adapter-pg';
import { Pool } from 'pg';

// 1. Konfigurasi Pool koneksi dari driver 'pg'
const pool = new Pool({ 
  connectionString: process.env.DATABASE_URL 
});

// 2. Buat Adapter untuk Prisma 7
const adapter = new PrismaPg(pool);

// 3. Inisialisasi Prisma Client (Singleton Pattern untuk Next.js)
const prismaClientSingleton = () => {
  return new PrismaClient({ adapter });
};

type PrismaClientSingleton = ReturnType<typeof prismaClientSingleton>;

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClientSingleton | undefined;
};

export const prisma = globalForPrisma.prisma ?? prismaClientSingleton();

export default prisma;

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;



Sekarang sesuaikan financial-contaxt.tsx aku ini tanpa mengubah logika yang sudah berjalan sebelumnya serta menunjukkan bagian mana yang berubah / ditambahkan agar sesuai dengan konsep kita local-first, cloud synced(?)
'use client';

import { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import type { Tabungan, Transaksi } from '@prisma/client';
import { useLocalStorage } from '@/hooks/useLocalStorage';
import { prisma } from '@/lib/prisma';
import * as XLSX from 'xlsx';

// Interface untuk data dari API (mungkin berbeda dari Prisma types)
interface TabunganData {
  id: number;
  nama: string;
  saldoAwal: number;
  jumlah: number;
  createdAt: string | Date;
  updatedAt: string | Date;
}

interface TransaksiData {
  id: number;
  judul: string;
  jumlah: number;
  deskripsi: string | null;
  tanggal: string | Date;
  tipe: string;
  kategoriId: number | null;
  tabunganId: number | null;
  createdAt: string | Date;
  updatedAt: string | Date;
}

// Data source types (disederhanakan untuk local-first)
type DataSource = 'local';

interface FinancialContextType {
  tabungan: TabunganData[];
  transaksi: TransaksiData[];
  refreshTabungan: () => Promise<void>;
  refreshTransaksi: () => Promise<void>;
  updateTabunganBalance: (id: number, newBalance: number) => void;
  userId: string;
  createTabungan: (data: { nama: string; saldoAwal: number }) => Promise<any>;
  createTransaksi: (data: {
    judul: string;
    jumlah: number;
    deskripsi?: string;
    tanggal: string;
    tipe: string;
    kategoriId?: number;
    tabunganId?: number;
  }) => Promise<any>;
  // Local storage integration
  dataSource: DataSource;
  isOnline: boolean;
  lastSync: Date | null;
  syncStatus: 'synced' | 'syncing' | 'offline' | 'error';
  forceSync: () => Promise<void>;
  exportData: (type: 'transactions' | 'savings') => Promise<void>;
  importData: (file: File) => Promise<any>;
}

const FinancialContext = createContext<FinancialContextType | undefined>(undefined);

// Helper function untuk user management (tidak berubah)
const getUserId = () => {
  if (typeof window === 'undefined') {
    return 'default_user';
  }
  
  let userId = localStorage.getItem('financeUserId');
  if (!userId) {
    userId = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    localStorage.setItem('financeUserId', userId);
    console.log('ðŸ†” Generated new userId:', userId);
  } else {
    console.log('ðŸ†” Using existing userId:', userId);
  }
  
  return userId;
};

export function FinancialProvider({ children }: { children: ReactNode }) {
  const [tabungan, setTabungan] = useState<TabunganData[]>([]);
  const [transaksi, setTransaksi] = useState<TransaksiData[]>([]);
  const [userId, setUserId] = useState<string>('default_user');
  
  // State untuk sinkronisasi (disederhanakan)
  const [syncStatus, setSyncStatus] = useState<'synced' | 'syncing' | 'offline' | 'error'>('synced');
  const [lastSync, setLastSync] = useState<Date | null>(null);

  // Initialize local storage hook
  const {
    tabungan: localTabungan,
    transaksi: localTransaksi,
    isOnline,
    loadFromLocal,
    saveToLocal,
    updateData
  } = useLocalStorage({
    userId: 'default_user', // Akan diperbarui saat userId siap
    autoSave: true,
    autoLoad: true
  });

  // Initialize userId on mount
  useEffect(() => {
    const currentUserId = getUserId();
    setUserId(currentUserId);
    console.log('ðŸ‘¤ FinancialProvider initialized with userId:', currentUserId);
  }, []);

  // Load initial data dari local storage saat userId siap
  useEffect(() => {
    if (userId !== 'default_user') {
      console.log('ðŸš€ FinancialProvider mounted, loading initial data for userId:', userId);
      loadFromLocal().then(() => {
        console.log('ðŸ“± Local data loaded');
        // Update state dengan data dari local storage
        setTabungan(localTabungan);
        setTransaksi(localTransaksi);
        setLastSync(new Date()); // Set last sync saat data dimuat
      });
    }
  }, [userId]);

  // Fungsi refresh hanya mengambil data dari local storage
  const refreshTabungan = async () => {
    console.log('ðŸ”„ Refreshing tabungan from local storage...');
    try {
      await loadFromLocal();
      setTabungan(localTabungan);
      console.log('âœ… Tabungan loaded from local storage');
    } catch (error) {
      console.error('Error loading tabungan from local storage:', error);
      setSyncStatus('error');
    }
  };

  const refreshTransaksi = async () => {
    console.log('ðŸ”„ Refreshing transaksi from local storage...');
    try {
      await loadFromLocal();
      setTransaksi(localTransaksi);
      console.log('âœ… Transaksi loaded from local storage');
    } catch (error) {
      console.error('Error loading transaksi from local storage:', error);
      setSyncStatus('error');
    }
  };

  // Update balance langsung di state dan local storage
  const updateTabunganBalance = (id: number, newBalance: number) => {
    console.log('ðŸ”„ Updating balance in context:', { id, newBalance, userId });
    
    const updatedTabungan = tabungan.map(t => 
      t.id === id ? { ...t, jumlah: newBalance, updatedAt: new Date() } : t
    );
    
    setTabungan(updatedTabungan);
    
    try {
      updateData(updatedTabungan, transaksi);
      setLastSync(new Date());
      console.log('ðŸ’¾ Balance updated in local storage');
    } catch (error) {
      console.warn('âš ï¸ Failed to update balance in local storage:', error);
    }
    
    console.log('âœ… Balance updated in context');
  };

  // Create tabungan langsung di state dan local storage
  const createTabungan = async (data: { nama: string; saldoAwal: number }) => {
    console.log('ðŸ’¾ Creating tabungan locally:', data);
    
    const newTabungan: TabunganData = {
      id: Date.now(), // Gunakan timestamp sebagai ID
      nama: data.nama,
      saldoAwal: data.saldoAwal,
      jumlah: data.saldoAwal,
      createdAt: new Date(),
      updatedAt: new Date()
    };
    
    const updatedTabungan = [...tabungan, newTabungan];
    setTabungan(updatedTabungan);
    
    try {
      await updateData(updatedTabungan, transaksi);
      setLastSync(new Date());
      console.log('âœ… Tabungan created and saved locally');
    } catch (error) {
      // Revert state jika gagal menyimpan
      setTabungan(tabungan);
      console.error('âŒ Failed to save tabungan:', error);
      throw error;
    }
    
    return newTabungan;
  };

  // Create transaksi langsung di state dan local storage
  const createTransaksi = async (data: {
    judul: string;
    jumlah: number;
    deskripsi?: string;
    tanggal: string;
    tipe: string;
    kategoriId?: number;
    tabunganId?: number;
  }) => {
    console.log('ðŸ’¾ Creating transaction locally:', data);
    
    const newTransaksi: TransaksiData = {
      id: Date.now(),
      judul: data.judul,
      jumlah: data.jumlah,
      deskripsi: data.deskripsi || null,
      tanggal: data.tanggal,
      tipe: data.tipe,
      kategoriId: data.kategoriId || null,
      tabunganId: data.tabunganId || null,
      createdAt: new Date(),
      updatedAt: new Date()
    };
    
    const updatedTransaksi = [newTransaksi, ...transaksi];
    setTransaksi(updatedTransaksi);
    
    // Update saldo tabungan jika ada tabunganId
    let updatedTabungan = tabungan;
    if (data.tabunganId) {
      const currentTabungan = tabungan.find(t => t.id === data.tabunganId);
      if (currentTabungan) {
        const newBalance = data.tipe === 'pengeluaran' 
          ? currentTabungan.jumlah - data.jumlah 
          : currentTabungan.jumlah + data.jumlah;
        
        updatedTabungan = tabungan.map(t => 
          t.id === data.tabunganId 
            ? { ...t, jumlah: newBalance, updatedAt: new Date() } 
            : t
        );
        setTabungan(updatedTabungan);
      }
    }
    
    try {
      await updateData(updatedTabungan, updatedTransaksi);
      setLastSync(new Date());
      console.log('âœ… Transaction created and saved locally');
    } catch (error) {
      // Revert state jika gagal menyimpan
      setTransaksi(transaksi);
      if (data.tabunganId) {
        setTabungan(tabungan);
      }
      console.error('âŒ Failed to save transaction:', error);
      throw error;
    }
    
    return newTransaksi;
  };

  // Force sync hanya me-refresh data dari local storage
  const forceSync = async () => {
    console.log('ðŸ”„ "Syncing" is just refreshing local data...');
    setSyncStatus('syncing');
    
    try {
      await refreshTabungan();
      await refreshTransaksi();
      setSyncStatus('synced');
      setLastSync(new Date());
      console.log('âœ… Local data refreshed');
    } catch (error) {
      console.error('âŒ Failed to refresh local data:', error);
      setSyncStatus('error');
    }
  };

  const exportData = async (type: 'transactions' | 'savings') => {
  try {
    let worksheet: XLSX.WorkSheet;
    let fileName: string;

    if (type === 'transactions') {
      // Siapkan data untuk transaksi
      const dataForExcel = transaksi.map(t => ({
        Tanggal: t.tanggal,
        Judul: t.judul,
        Keterangan: t.deskripsi || '',
        Jumlah: t.jumlah,
        Tipe: t.tipe,
        Tabungan: tabungan.find(tab => tab.id === t.tabunganId)?.nama || 'Tidak diketahui'
      }));
      worksheet = XLSX.utils.json_to_sheet(dataForExcel);
      fileName = `Laporan_Keuangan_${new Date().toISOString().split('T')[0]}.xlsx`;
    } else {
      // Siapkan data untuk tabungan
      const dataForExcel = tabungan.map(t => ({
        Nama: t.nama,
        Saldo: t.jumlah,
        'Dibuat Tanggal': new Date(t.createdAt).toLocaleDateString('id-ID')
      }));
      worksheet = XLSX.utils.json_to_sheet(dataForExcel);
      fileName = `Laporan_Tabungan_${new Date().toISOString().split('T')[0]}.xlsx`;
    }

    // Buat workbook dan tambahkan worksheet
    const workbook = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(workbook, worksheet, type === 'transactions' ? 'Transaksi' : 'Tabungan');

    // Konversi workbook ke buffer lalu trigger download
    const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
    const blob = new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
    
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = fileName;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);

    console.log(`âœ… ${type} exported successfully`);
  } catch (error) {
    console.error(`âŒ Failed to export ${type}:`, error);
    throw error;
  }
};

// Fungsi untuk import dari Excel
const importData = async (file: File) => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = async (e) => {
      try {
        const data = e.target?.result;
        const workbook = XLSX.read(data, { type: 'binary' });
        
        // Asumsikan kita mengimpor dari sheet pertama
        const sheetName = workbook.SheetNames[0];
        const worksheet = workbook.Sheets[sheetName];
        const jsonData = XLSX.utils.sheet_to_json(worksheet);

        // Validasi dan proses data yang diimpor
        const importedTransactions: any[] = [];
        for (const row of jsonData as any[]) {
          // Sesuaikan dengan kolom di Excel kamu
          if (row.Tanggal && row.Jumlah && row.Tipe) {
            const newTransaction = {
              id: Date.now() + Math.random(), // ID sementara
              judul: row.Judul || 'Transaksi Import',
              jumlah: parseFloat(row.Jumlah),
              deskripsi: row.Keterangan || null,
              tanggal: new Date(row.Tanggal).toISOString().split('T')[0],
              tipe: row.Tipe,
              tabunganId: tabungan.find(t => t.nama === row.Tabungan)?.id || null,
              kategoriId: null,
              createdAt: new Date(),
              updatedAt: new Date()
            };
            importedTransactions.push(newTransaction);
          }
        }

        // Update state dan local storage
        const updatedTransaksi = [...importedTransactions, ...transaksi];
        setTransaksi(updatedTransaksi);
        await updateData(tabungan, updatedTransaksi);
        setLastSync(new Date());

        console.log(`âœ… ${importedTransactions.length} transactions imported successfully`);
        resolve(importedTransactions);
      } catch (error) {
        console.error('âŒ Failed to import data:', error);
        reject(error);
      }
    };
    reader.onerror = () => reject(new Error('Gagal membaca file'));
    reader.readAsBinaryString(file);
  });
};

  return (
    <FinancialContext.Provider value={{
      tabungan,
      transaksi,
      refreshTabungan,
      refreshTransaksi,
      updateTabunganBalance,
      userId,
      createTabungan,
      createTransaksi,
      // Local storage integration
      dataSource: 'local', // Selalu 'local'
      isOnline,
      lastSync,
      syncStatus,
      forceSync,
      exportData,
      importData
    }}>
      {children}
    </FinancialContext.Provider>
  );
}

export function useFinancial() {
  const context = useContext(FinancialContext);
  if (context === undefined) {
    throw new Error('useFinancial must be used within a FinancialProvider');
  }
  return context;
}